#!/usr/bin/env perl6

# quick script to translate w3c property definitions to draft
# Perl 6 grammars and actions.
#
# it was used to generate the initial grammar and actions for
# CSS::Language:CSS1 and CSS::Language:CSS21 and many of the extension modules.
#
# Example: perl6 etc/gen-properties.pl grammar etc/css21-properties.txt
#

use CSS::Language::Specification;
use CSS::Language::Specification::Actions;

#= generate parsing grammar
multi MAIN(Str $properties-spec, Str :$grammar, Bool :$proforma?) {

    my $actions = CSS::Language::Specification::Actions.new;
    my @defs = load-props($properties-spec, $actions);

    say "use v6;";
    say "#  -- DO NOT EDIT --";
    say "# generated by: gen-properties.pl {@*ARGS}";

    say "grammar {$grammar} \{";

    generate-perl6-rules(@defs, :$proforma);

    say '}';
}

#= generate actions class
multi MAIN(Str $properties-spec, Str :$class) {

    my $actions = CSS::Language::Specification::Actions.new;
    my @defs = load-props($properties-spec, $actions);

    say "use v6;";
    say "#  -- DO NOT EDIT --";
    say "# generated by gen-properties.pl {@*ARGS}";

    say "class {$class} \{";

    generate-perl6-actions(@defs);

    say '}';
}

#= generate interface roles.
multi MAIN(Str $properties-spec, Str :$role) {

    my $actions = CSS::Language::Specification::Actions.new;
    my @defs = load-props($properties-spec, $actions);

    say "use v6;";
    say "#  -- DO NOT EDIT --";
    say "# generated by gen-properties.pl {@*ARGS}";

    say "role {$role} \{";

    generate-perl6-interface(@defs);

    say '}';
}

sub load-props ($properties-spec, $actions?) {
    my $fh = open($properties-spec // "etc/css21-properties.txt");

    my @props;

    for $fh.lines -> $prop-spec {
        # handle full line comments
        next if $prop-spec ~~ /^'#'/;

        my $/ = CSS::Language::Specification.subparse($prop-spec, :rule('property-spec'), :actions($actions) );
        die "unable to parse: $prop-spec"
            unless $/.ast;
        my $prop-defn = $/.ast;

	@props.push: $prop-defn;
    }

    return @props;
}

sub generate-perl6-rules(@defs, :$proforma) {

    my %seen;

    my $proforma-str = $proforma ?? ' | <proforma> ' !! '';

    for @defs -> $def {

        my @props = @( $def<props> );
        my $terms = $def<terms>;
        my $synopsis = $def<synopsis>;
        my $is-rule = $synopsis ~~ /^ <CSS::Language::Specification::property-ref> $/;

        for @props -> $prop {
            next if %seen{$prop}++;
            my $match = $prop.subst(/\-/, '\-'):g;

            say;
            say "#= $prop: $synopsis";
            say "    rule decl:sym<{$prop}> \{:i ($match) ':'  [ <expr=.expr-{$prop}>{$proforma-str} || <any-args> ] \}";
            say "    rule expr-$prop \{:i $terms \}";
        }
    }
}

sub generate-perl6-actions(@defs) {

    my %seen;

    for @defs -> $def {

        my @props = @( $def<props> );
        my $synopsis = $def<synopsis>;

        # automagical detection of 'boxed' properties, eg: margin: [ <length> | <percentage> | auto ]{1,4} 
        my $boxed = $synopsis ~~ / '{1,4}' $/;

        for @props -> $prop {
            next if %seen{$prop}++;
            say;
            say "    #= {$prop}: $synopsis";
            say "    method decl:sym<{$prop}>(\$/) \{ make \$.decl(\$/, \&\?ROUTINE.WHY{ $boxed ?? ', :boxed' !! ''}) \}";
            say "    method expr-{$prop}(\$/) \{ make \$.list(\$/) \}";
        }
    }
}


#= generate an interface class for all unresolved terms.
sub generate-perl6-interface(@defs, %references) {

    my %unresolved = %references;

    for @defs -> $def {

        %unresolved{$_}:delete
            for @( $def<props> );
    }

    for %unresolved.keys.sort -> $sym {
        say "    method {$sym}(\$/) \{ ... \}";
    }
}
